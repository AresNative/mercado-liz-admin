"use client";

import { useState, useEffect, useMemo } from "react";
import {
  Button,
  Card,
  Dropdown,
  DropdownItem,
  DropdownMenu,
  DropdownTrigger,
} from "@nextui-org/react";
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragOverlay,
  sortableKeyboardCoordinates,
} from "@dnd-kit/core";
import ReportInputs from "@/components/func/report-inputs";
import ReportTable from "@/components/ui/report-table";
import {
  useGetAlmacenQuery,
  useGetComprasQuery,
  useGetMermasQuery,
  useGetMovimientosQuery,
  useGetVentasQuery,
} from "@/store/server/reducers/api-reducer";
import { Bar } from "react-chartjs-2";
import {
  Chart as ChartJS,
  BarElement,
  CategoryScale,
  LinearScale,
  Tooltip,
  Legend,
} from "chart.js";
import { DefaultPage } from "@/template/default-page";
import { Filter } from "lucide-react";

// Registrar los componentes de Chart.js
ChartJS.register(CategoryScale, LinearScale, BarElement, Tooltip, Legend);

export default function GeneradorReportes() {
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [filter, setFilter] = useState({
    codigo: "",
    articulo: "",
    proveedor: "",
    descripcion: "",
  });
  const [filterType, setFilterType] = useState("codigo");
  const [draggedColumn, setDraggedColumn] = useState(null);
  const [previewData, setPreviewData] = useState([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalRecords, setTotalRecords] = useState(0);
  const [sortConfig, setSortConfig] = useState({ key: null, direction: "asc" });
  const [selectedKeys, setSelectedKeys] = useState("get-compras");

  const itemsPerPage = 8;

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  const buildQueryString = () => {
    const query = new URLSearchParams();
    if (filter[filterType]) query.append(filterType, filter[filterType]);
    if (startDate) query.append("startDate", startDate);
    if (endDate) query.append("endDate", endDate);
    query.append("page", currentPage);
    query.append("pageSize", itemsPerPage);
    return query.toString();
  };
  const handleSort = (columnId) => {
    // Determinar la dirección del ordenamiento: alterna entre "asc" y "desc"
    const direction =
      sortConfig.key === columnId && sortConfig.direction === "asc"
        ? "desc"
        : "asc";

    // Actualizar la configuración del ordenamiento
    setSortConfig({ key: columnId, direction });

    // Verifica si los datos están disponibles
    if (Array.isArray(previewData) && previewData.length > 0) {
      // Ordena los datos basados en la columna seleccionada
      const sortedData = [...previewData].sort((a, b) => {
        if (a[columnId] < b[columnId]) return direction === "asc" ? -1 : 1;
        if (a[columnId] > b[columnId]) return direction === "asc" ? 1 : -1;
        return 0;
      });

      // Actualiza el estado con los datos ordenados
      setPreviewData(sortedData);
    }
  };

  const useDataQuery = (actionType, buildQueryString) => {
    const queryOptions = { refetchOnMountOrArgChange: true };
    const queryMap = {
      "get-compras": useGetComprasQuery,
      "get-ventas": useGetVentasQuery,
      "get-almacen": useGetAlmacenQuery,
      "get-mermas": useGetMermasQuery,
      "get-movimientos": useGetMovimientosQuery,
    };

    const queryFunction =
      queryMap[actionType] ||
      (() => ({
        data: null,
        error: null,
        isLoading: false,
        refetch: () => {},
      }));

    return queryFunction(buildQueryString(), queryOptions);
  };

  const { data, error, isLoading, refetch } = useDataQuery(
    selectedKeys,
    buildQueryString
  );

  const handleFilterTypeChange = (e) => {
    setCurrentPage(1); // Reiniciar la página al cambiar el tipo de filtro
    setFilterType(e.target.value); // Cambiar el tipo de filtro
    setFilter(""); // Reiniciar el valor del filtro
  };

  const handleFilterChange = (e) => {
    const value = e.target.value;
    setFilter((prev) => ({
      ...prev,
      [filterType]: value,
    }));
  };

  const handlePageChange = (newPage) => {
    if (newPage >= 1 && newPage <= Math.ceil(totalRecords / itemsPerPage)) {
      setCurrentPage(newPage);
    }
  };

  const chartData = {
    labels: previewData.map((item) =>
      new Date(item.FechaEmision).toLocaleDateString()
    ),
    datasets: [
      {
        label: "Cantidad",
        data: previewData.map((item) => item.Cantidad),
        backgroundColor: "rgba(75, 192, 192, 0.6)",
        borderColor: "rgba(75, 192, 192, 1)",
        borderWidth: 1,
      },
    ],
  };

  const handleDragEnd = (event) => {
    const { active, over } = event;
    setDraggedColumn(null);
  };

  useMemo(() => {
    // Limpiar todos los estados al cambiar selectedKeys
    setPreviewData([]); // Limpiar los datos previos
    setTotalRecords(0); // Limpiar el total de registros
    setCurrentPage(1); // Reiniciar a la primera página

    // Realizar el refetch si selectedKeys es válido
    if (selectedKeys && data !== undefined) {
      refetch(); // Solo refetch si hay una selección válida
    }
  }, [
    selectedKeys,
    filterType,
    currentPage,
    filter,
    startDate,
    endDate,
    refetch,
  ]);

  useEffect(() => {
    // Unificar lógica de actualización de datos
    if (data && Array.isArray(data.data)) {
      setPreviewData(data.data); // Asignar solo si data.data es un array
      setTotalRecords(data.totalRecords || 0); // Asignar totalRecords o 0 si no existe
    } else {
      setPreviewData([]); // Si data no es un array o no existe, asignar array vacío
      setTotalRecords(0); // Asegurar que totalRecords sea 0 en caso de error
    }
  }, [data]);

  return (
    <DefaultPage>
      <section className="flex flex-col lg:flex-row gap-4">
        <Card className="flex-1 w-full mt-2 mx-auto p-8">
          <section className="flex justify-between">
            <h2 className="text-2xl font-bold mb-6">Búsqueda rápida</h2>
            <Button size="sm" variant="bordered">
              <Filter size={16} strokeWidth={0.75} />
            </Button>
          </section>
          <ReportInputs
            filterType={filterType}
            setStartDate={setStartDate}
            setEndDate={setEndDate}
            handleFilterTypeChange={handleFilterTypeChange}
            handleFilterChange={handleFilterChange}
          />
        </Card>
        <Card className="flex-1 w-full mt-2 mx-auto p-8">
          {isLoading ? (
            <p>Cargando...</p>
          ) : error ? (
            <p>Error al cargar los datos</p>
          ) : (
            previewData.length > 0 && (
              <Bar
                data={chartData}
                options={{ responsive: true }}
                className="w-full max-h-60 min-h-44"
              />
            )
          )}
        </Card>
      </section>

      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={handleDragEnd}
        onDragStart={(event) => setDraggedColumn(event.active.id)}
      >
        <section className="flex flex-col lg:flex-row gap-4 mt-3">
          <Card className="flex-1 p-4 shadow-md">
            <section className="max-w-16 m-1">
              <Dropdown>
                <DropdownTrigger>
                  <Button variant="bordered" className="capitalize">
                    {selectedKeys}
                  </Button>
                </DropdownTrigger>
                <DropdownMenu
                  variant="flat"
                  closeOnSelect={false}
                  disallowEmptySelection
                  selectionMode="single"
                  selectedKeys={selectedKeys}
                  onSelectionChange={setSelectedKeys}
                >
                  <DropdownItem key="get-compras">Compras</DropdownItem>
                  <DropdownItem key="get-ventas">Ventas</DropdownItem>
                  <DropdownItem key="get-mermas">Mermas</DropdownItem>
                  <DropdownItem key="get-movimientos">Movimientos</DropdownItem>
                  <DropdownItem key="get-almacen">Almacen</DropdownItem>
                </DropdownMenu>
              </Dropdown>
            </section>

            {isLoading ? (
              <p>Cargando...</p>
            ) : error ? (
              <p>Error al cargar los datos</p>
            ) : (
              <ReportTable
                paginatedData={previewData}
                isDragging={!!draggedColumn}
                onSort={handleSort}
                sortConfig={sortConfig}
              />
            )}

            <div className="flex justify-between items-center mt-4">
              <span>
                Mostrando {(currentPage - 1) * itemsPerPage + 1} -{" "}
                {Math.min(currentPage * itemsPerPage, totalRecords)} de{" "}
                {totalRecords}
              </span>
              <div className="flex gap-2">
                <Button
                  onClick={() => handlePageChange(currentPage - 1)}
                  disabled={currentPage === 1}
                  bordered
                >
                  Anterior
                </Button>
                <Button
                  onClick={() => handlePageChange(currentPage + 1)}
                  disabled={
                    currentPage === Math.ceil(totalRecords / itemsPerPage)
                  }
                  bordered
                >
                  Siguiente
                </Button>
              </div>
            </div>
          </Card>
        </section>
      </DndContext>
    </DefaultPage>
  );
}
